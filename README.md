<h1 align="center">
	📘 Classic Computer Science Problems In Python
</h1>

<p align="center">
  <i>Code along with  <b>"Classic Computer Science Problems in Python"</b> by David Kopec.</i>
</p>


<p align="center">
	<img alt="GitHub code size in bytes" src="https://img.shields.io/github/languages/code-size/appinha/book-ClassicComputerScienceProblemsInPython?color=blueviolet" />
	<img alt="Number of lines of code" src="https://img.shields.io/tokei/lines/github/appinha/book-ClassicComputerScienceProblemsInPython?color=blueviolet" />
	<img alt="Code language count" src="https://img.shields.io/github/languages/count/appinha/book-ClassicComputerScienceProblemsInPython?color=blue" />
	<img alt="GitHub top language" src="https://img.shields.io/github/languages/top/appinha/book-ClassicComputerScienceProblemsInPython?color=blue" />
	<img alt="GitHub last commit" src="https://img.shields.io/github/last-commit/appinha/book-ClassicComputerScienceProblemsInPython?color=brightgreen" />
</p>

<h3 align="center">
	<a href="#%EF%B8%8F-about">About</a>
	<span> · </span>
	<a href="#-contents">Contents</a>
</h3>

---

## 🗣️ About

> _Classic Computer Science Problems in Python_ presents dozens of coding challenges, ranging from simple tasks like finding items in a list with a binary sort algorithm to clustering data using k-means.
>
> _Classic Computer Science Problems in Python_ deepens your Python language skills by challenging you with time-tested scenarios, exercises, and algorithms. As you work through examples in search, clustering, graphs, and more, you'll remember important things you've forgotten and discover classic solutions to your "new" problems

## 📑 Contents

### Chapter 1 - Small problems

- 1.1 The Fibonacci sequence
  - 1.1.1 A first recursive attempt
  - 1.1.2 [Utilizing base cases](Chapter1/1.1-fib2.py)
  - 1.1.3 [Memoization to the rescue](Chapter1/1.1-fib3.py)
  - 1.1.4 [Automatic memoization](Chapter1/1.1-fib4.py)
  - 1.1.5 [Keep it simple, Fibonacci](Chapter1/1.1-fib5.py)
  - 1.1.6 [Generating Fibonacci numbers with a generator](Chapter1/1.1-fib6.py)
- 1.2 [Trivial compression](Chapter1/1.2-trivial_compression.py)
- 1.3 [Unbreakable encryption](Chapter1/1.3-unbreakable_encryption.py)
- 1.4 [Calculating pi](Chapter1/1.4-calculating_pi.py)
- 1.5 [The Towers of Hanoi](Chapter1/1.5-towers_of_hanoi.py)
- 1.6 Real-world applications
- 1.7 Exercises

### Chapter 2 - Search problems

- 2.1 [DNA search](Chapter2/2.1-dna_search.py)
- 2.2 [Maze solving](Chapter2/2.2-maze.py)
- 2.3 [Missionaries and cannibals](Chapter2/2.3-missionaries.py)
- 2.4 Real-world applications
- 2.5 Exercises
- [Generic search](Chapter2/generic_search.py)

### Chapter 3 - Constraint-satisfaction problems

- 3.1 [Building a constraint-satisfaction problem framework](Chapter3/csp.py)
- 3.2 [The Australian map-coloring problem](Chapter3/3.2-map_coloring.py)
- 3.3 [The eight queens problem](Chapter3/3.3-eight_queens.py)
- 3.4 [Word search](Chapter3/3.4-word_search.py)
- 3.5 [SEND+MORE=MONEY](Chapter3/3.5-send_more_money.py)
- 3.6 [Circuit board layout](Chapter3/3.6-circuit_board_layout.py)
- 3.7 Real-world applications
- 3.8 Exercises
  - [Sudoku solver](Chapter3/3.8-sudoku.py)

### Chapter 4 - Graph problems

- 4.1 A map as a graph
- 4.2 Building a graph framework
  - [Edge](Chapter4/edge.py)
  - [Graph](Chapter4/graph.py)
- 4.3 Finding the shortest path
- 4.4 Minimizing the cost of building the network
  - [Weighted Edge](Chapter4/weighted_edge.py)
  - [Weighted Graph](Chapter4/weighted_graph.py)
  - [Priority Queue](Chapter4/priority_queue.py)
  - [Minimum Spanning Tree](Chapter4/mst.py)
- 4.5 Finding shortest paths in a weighted graph
  - [Dijkstra’s algorithm](Chapter4/dijkstra.py)
- 4.6 Real-world applications
- 4.7 Exercises